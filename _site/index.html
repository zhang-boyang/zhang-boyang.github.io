<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0">
        <link rel="alternate" type="application/rss+xml" href="/atom.xml" />
        <link rel="shortcut icon" type="image/png" href="/images/icon.jpg" />
        <link href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css?family=PT+Serif" rel="stylesheet">
        <link rel="stylesheet" href="/assets/css/bootstrap.min.css">
        <link rel="stylesheet" href="/assets/css/share.min.css">
        <link rel="stylesheet" href="/assets/css/highlight/github-gist.css">
        <script src="/assets/js/jquery.min.js"></script>
        <script src="/assets/js/jquery.share.min.js"></script>
        <script src="/assets/js/highlight.pack.js"></script>
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>
        <script> hljs.initHighlightingOnLoad(); </script>
        
        <title>Note of John Brown</title>
        
    </head>
    <body>
        <div class="container-fluid">
            <div class="row row-header">
                <div class="col-md-6 col-md-offset-3">
                    <ul class="list-inline list-nav">
                        <li><a href="/"><b>Note of John Brown</b></a></li>
                        <li><a href="/archive">archive</a></li>
                        <li><a href="/about">about</a></li>
                        <li><a href="/atom.xml">atom</a></li>
                    </ul>
                </div>
            </div>

            <div class="row">
                <div class="col-xs-12 col-sm-12 col-md-6 col-md-offset-3 col-main">
                    
  <h1><a href="/2020/02/08/raft%E5%8F%AA%E8%AF%BB%E6%93%8D%E4%BD%9C%E4%BC%98%E5%8C%96.html">raft只读操作优化</a></h1>

  <div class="content">

    
      <h1 id="id-raft-只读操作优化">Raft 只读操作优化</h1> <h2 id="id-为什么需要优化只读操作">为什么需要优化只读操作</h2> <p>raft是一个为分布式集群达成一致性的协议。对于集群需要保证一致性的数据，每次一操作其实都要确认此操作是否在集群中达成了一致。从是否会改变数据的角度，操作就分两个<strong>只读操作</strong>与<strong>写操作</strong>。只读操作顾名思义就是不会对数据做任何的改动。写操作包含了增删改等需要修改数据的操作，通俗说就是这次操作处理完后，数据有可能跟操作前不一样。</p> <p>正是因为只读操作不对数据进行修改，所以raft可以优化只读操作。</p> <ol> <li> <p>因为只要客户端请求的是现集群真正的leader，那么获取到的数据就不会有错误。一个只读操作没有必要征求整个raft集群的共识。毕竟使用raft达成一个操作的共识还需要多节点网络请求与log持久化落磁盘等开销。</p>...
      <br/>
      <a href="/2020/02/08/raft%E5%8F%AA%E8%AF%BB%E6%93%8D%E4%BD%9C%E4%BC%98%E5%8C%96.html">read more</a>
   

    <p>
      <span class="gray">08 Feb 2020 by John Brown</span>
    </p>
  </div>

  <h1><a href="/2019/12/19/LRU%E7%AE%97%E6%B3%95%E5%BB%BA%E6%A8%A1.html">LRU算法建模</a></h1>

  <div class="content">

    
      <h2 id="id-什么是lruleast-recently-used">什么是LRU(Least-Recently Used)</h2> <ul> <li> <p>缓存的队列长度(容量)为<script type="math/tex">S</script>, 一共有<script type="math/tex">K</script>的项, K »...
      <br/>
      <a href="/2019/12/19/LRU%E7%AE%97%E6%B3%95%E5%BB%BA%E6%A8%A1.html">read more</a>
   

    <p>
      <span class="gray">19 Dec 2019 by John Brown</span>
    </p>
  </div>

  <h1><a href="/2019/09/28/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%88%86%E7%89%87%E7%9A%84%E8%89%BA%E6%9C%AF(2017-6.824-Lab4).html">分布式系统分片的艺术(2017-6.824 Lab4)</a></h1>

  <div class="content">

    
      <h2 id="id-为什么要分片">为什么要”分片”</h2> <p>分片即将整体的数据分而治之。以多节点系统工作的方式共同完成一个工作。能够减轻节点服务器压力，提高整个集群节点利用率与性能。</p> <p>这里引申出一个问题，为什么需要使用分片这一方式。在分布式系统中，有主副节点(master replica 数据上，Leader Follower raft一致性协议上)。能否在主副节点同时对数据进行操作，哪怕只是对副本进行读操作。至少在要求<strong>强一致</strong>或者<strong>线性一致的</strong>的存储系统中，答案是否定的。在这些系统中，副本只负责提高分布式系统的可用性，对系统的容灾性进行提升。client不能使用replica中的数据。因为副本节点没有向一致性propose的权利，无法保证这次操作已达成了共识。最主要的原因就是如果集群出现了脑裂,导致线性不一致。</p> <p>这里需要提到一点，就是原始的paxos协议，没有raft的leader和follower的区别。paxos角色为proposer和acceptor，但是任何节点都同时扮演这两种角色，一个基础的paxos协议需要多次网络请求（prepare，accept…）。任何节点都可以进行propose的结果就是导致了非常容易发生冲突，在多请求时很很难达成共识。所以一般在工程实现时使用multi-paxos，即也是选出leader打头阵。</p> <h2...
      <br/>
      <a href="/2019/09/28/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%88%86%E7%89%87%E7%9A%84%E8%89%BA%E6%9C%AF(2017-6.824-Lab4).html">read more</a>
   

    <p>
      <span class="gray">28 Sep 2019 by John Brown</span>
    </p>
  </div>

  <h1><a href="/2019/09/28/Raft%E7%9A%84go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E4%B8%8E%E4%BD%BF%E7%94%A8(2017-6.824-Lab2-Lab3).html">Raft的go语言实现与使用(2017-6.824 Lab2-Lab3)</a></h1>

  <div class="content">

    
      <p>Raft协议的解读已经有很多，整体最主要的协议其实用论文中的两幅图就能大致表述了。最后再加上一个Snapshot的图解析基本就全。相对与Paxos而言，我个人认为Raft从实现协议的角度来说反而比Paxos要复杂。主要就是在于index的处理上。这此使用Go语言实现了一个Raft协议并支持snapshot。并且使用Raft协议实现了一个分布式的kv存储。</p> <h2 id="id-raft的实现">Raft的实现</h2> <h3 id="id-raft的成员变量">Raft的成员变量</h3> <pre><code class="language-go"> type Raft struct...
      <br/>
      <a href="/2019/09/28/Raft%E7%9A%84go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%E4%B8%8E%E4%BD%BF%E7%94%A8(2017-6.824-Lab2-Lab3).html">read more</a>
   

    <p>
      <span class="gray">28 Sep 2019 by John Brown</span>
    </p>
  </div>

  <h1><a href="/2019/01/29/%E5%85%B3%E4%BA%8EABtest%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E6%AD%A3%E4%BA%A4%E6%80%A7%E8%AE%A8%E8%AE%BA.html">关于ABtest哈希算法正交性讨论</a></h1>

  <div class="content">

    
      <h1 id="id-关于abtest哈希算法正交性讨论">关于ABtest哈希算法正交性讨论</h1> <h2 id="id-hash正交性">Hash正交性</h2> <p>正交性定义：首先任意一个hash_type都可以均匀的将流量均匀分成100份。使用hash_type1 进行哈希后得到<script type="math/tex">x_i,i\in[0,100)</script>,即每份百分之1的流量，再使用hash_type2进行哈希后得到<script type="math/tex">y_i,i\in[0,100)</script>。如果某个key在被hash_type1进行hash后得到的流量与被hash_type2得到的流量是无关的，那么就说明hash_type1与hash_type2是两中hash方式是正交的。</p> <p>例如一个1000000用户的流量，经过hash_type1与hash_type2进行hash，理想情况下 中具有相同每份y中的相同x流量的个数也是同样多的，即100个。如果使用数组命中计数的话，list[<script...
      <br/>
      <a href="/2019/01/29/%E5%85%B3%E4%BA%8EABtest%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E6%AD%A3%E4%BA%A4%E6%80%A7%E8%AE%A8%E8%AE%BA.html">read more</a>
   

    <p>
      <span class="gray">29 Jan 2019 by John Brown</span>
    </p>
  </div>

  <h1><a href="/2018/08/20/ThreadPool,-Coroutine,-Promise%E4%B8%8EFuture.html">ThreadPool, Coroutine, Promise与Future</a></h1>

  <div class="content">

    
      <h1 id="id-threadpool-coroutine-promise与future">ThreadPool, Coroutine, Promise与Future</h1> <h2 id="id-threadpool">ThreadPool</h2> <p>线程池，顾名思义，就是放着很多线程的大“池子”。主要用作并发量大，但每个任务需要处理的时间不是很长。比如接受或者发送网络请求的任务。之所以使用线程池，原因就是在线程的传创建和销毁在高并发先开销十分大，如果将线程先创建好放入“池子”中待命，随用随取。降低不必要的开销十分划算。</p> <p>实现也非常的简单，创建队列，使用生产消费者模型（向队列中增加任务即生产者，将任务执行完成即消费者）。主要实现逻辑如下：</p> <pre><code class="language-c++">ThreadPool::ThreadPool(int...
      <br/>
      <a href="/2018/08/20/ThreadPool,-Coroutine,-Promise%E4%B8%8EFuture.html">read more</a>
   

    <p>
      <span class="gray">20 Aug 2018 by John Brown</span>
    </p>
  </div>


<br/>


<div class="pagination">
  
    <span>&laquo; Prev</span>
  

  
    
      <em>1</em>
      
    
    
      <a href="/page2">2</a>
    
  

  
    <a href="/page2">Next &raquo;</a>
  
</div>

                </div>
            </div>
        </div>
    <link rel="stylesheet" href="/assets/css/blog.css">
    </body>
</html>
